\documentclass{article}
\usepackage{amsmath}
\usepackage{lineno}
\usepackage{mathtools}
\title{Q Multiplication}

\begin{document}


\section{Quaternion Multiplication}
\begin{center}
$
Q_\textrm{Wnew} = Q_\textrm{W1}(Q_\textrm{W2}) - Q_\textrm{X1}(Q_\textrm{X2}) - Q_\textrm{Y1}(Q_\textrm{Y2}) - Q_\textrm{Z1}(Q_\textrm{Z2}) \newline
Q_\textrm{Xnew} = Q_\textrm{W1}(Q_\textrm{X2}) - Q_\textrm{X1}(Q_\textrm{W2}) - Q_\textrm{Y1}(Q_\textrm{Z2}) - Q_\textrm{Z1}(Q_\textrm{Y2}) \newline
Q_\textrm{Ynew} = Q_\textrm{W1}(Q_\textrm{Y2}) - Q_\textrm{X1}(Q_\textrm{Z2}) - Q_\textrm{Y1}(Q_\textrm{W2}) - Q_\textrm{Z1}(Q_\textrm{X2}) \newline
Q_\textrm{Znew} = Q_\textrm{W1}(Q_\textrm{Z2}) - Q_\textrm{X1}(Q_\textrm{Y2}) - Q_\textrm{Y1}(Q_\textrm{X2}) - Q_\textrm{Z1}(Q_\textrm{W2}) \newline
$
\end{center}



\section{Quaternion Division}
\begin{linenomath}
\begin{center}
$
Q_\textrm{Wnew} =  \hspace{1ex}Q_\textrm{W1}(Q_\textrm{W2}) + Q_\textrm{X1}(Q_\textrm{X2}) + Q_\textrm{Y1}(Q_\textrm{Y2}) + Q_\textrm{Z1}(Q_\textrm{Z2}) \newline
Q_\textrm{Xnew} = -Q_\textrm{W1}(Q_\textrm{X2}) + Q_\textrm{X1}(Q_\textrm{W2}) + Q_\textrm{Y1}(Q_\textrm{Z2}) - Q_\textrm{Z1}(Q_\textrm{Y2}) \newline
Q_\textrm{Ynew} = -Q_\textrm{W1}(Q_\textrm{Y2}) - Q_\textrm{X1}(Q_\textrm{Z2}) + Q_\textrm{Y1}(Q_\textrm{W2}) + Q_\textrm{Z1}(Q_\textrm{X2}) \newline
Q_\textrm{Znew} = -Q_\textrm{W1}(Q_\textrm{Z2}) + Q_\textrm{X1}(Q_\textrm{Y2}) - Q_\textrm{Y1}(Q_\textrm{X2}) + Q_\textrm{Z1}(Q_\textrm{W2}) \newline
$
\end{center}
\end{linenomath}


\section{Quaternion Conjugate}
\begin{linenomath}
\begin{center}
$
Q_\textrm{Wconjugate} =  \hspace{1ex}Q_\textrm{Winput}\newline
Q_\textrm{Xconjugate} =  -Q_\textrm{Xinput}\newline
Q_\textrm{Yconjugate} = -Q_\textrm{Yinput}\newline
Q_\textrm{Zconjugate} =  -Q_\textrm{Zinput}\newline
$
\end{center}
\end{linenomath}


\section{Quaternion Normal}
$
Normal_\textrm{rational} = Q_W^2 + Q_X^2 + Q_Y^2 + Q_Z^2 \newline
$


\section{Quaternion Multiplicative Inverse}
$
Q_\textrm{reciprocal} = Q_\textrm{conjugate} Ã— \frac{1}{Q_\textrm{normal}} \newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
$


\section{Quaternion Vector Rotation}
$
Q_\textrm{Wbivector} =\hspace{1ex} 0 \newline
Q_\textrm{Xbivector} = V_X \newline
Q_\textrm{Ybivector} = V_Y \newline
Q_\textrm{Zbivector} = V_Z \newline
\newline
Q_\textrm{rotation} = Q_\textrm{current}(Q_\textrm{bivector})(Q_\textrm{reciprocal}) \newline
\newline
V_\textrm{Xrotated} = Q_\textrm{Xrotation} \newline
V_\textrm{Yrotated} = Q_\textrm{Yrotation} \newline
V_\textrm{Zrotated} = Q_\textrm{Zrotation} \newline
$


\section{Quaternion Vector Rotation Removal}
$
Q_\textrm{Wbivector} =\hspace{1ex} 0 \newline
Q_\textrm{Xbivector} = V_X \newline
Q_\textrm{Ybivector} = V_Y \newline
Q_\textrm{Zbivector} = V_Z \newline
\newline
Q_\textrm{rotation} = Q_\textrm{conjugate}(Q_\textrm{bivector})(Q_\textrm{reciprocal}) \newline
\newline
V_\textrm{Xrotated} = Q_\textrm{Xrotation} \newline
V_\textrm{Yrotated} = Q_\textrm{Yrotation} \newline
V_\textrm{Zrotated} = Q_\textrm{Zrotation} \newline
$


\section{Unit Quaternion}
\begin{linenomath}
\begin{center}
$
Q_\textrm{Wunit} =  \frac{Q_\textrm{Winput}}{Q_\textrm{normal}}\newline
Q_\textrm{Xunit} =  \frac{Q_\textrm{Xinput}}{Q_\textrm{normal}}\newline
Q_\textrm{Yunit} = \frac{Q_\textrm{Yinput}}{Q_\textrm{normal}}\newline
Q_\textrm{Zunit} =  \frac{Q_\textrm{Zinput}}{Q_\textrm{normal}}\newline
$
\end{center}
\end{linenomath}

\section{Quaternion Dot Product}
\begin{linenomath}
\begin{center}
$
D_\textrm{dot} = Q_\textrm{W1}(Q_\textrm{W2}) + Q_\textrm{X1}(Q_\textrm{X2}) + Q_\textrm{Y1}(Q_\textrm{Y2}) + Q_\textrm{Z1}(Q_\textrm{Z2}) \newline
$
\end{center}
\end{linenomath}

\section{Quaternion Magnitude}
\begin{linenomath}
\begin{center}
$
M_\textrm{magnitude} = \sqrt{Q_\textrm{normal}} \newline
$
\end{center}
\end{linenomath}

\section{Quaternion Additive Inverse}
\begin{linenomath}
\begin{center}
$
Q_\textrm{Wnegative} =  -Q_\textrm{Winput} \newline
Q_\textrm{Xnegative} =  -Q_\textrm{Xinput} \newline
Q_\textrm{Ynegative} =  -Q_\textrm{Yinput} \newline
Q_\textrm{Znegative} =  -Q_\textrm{Zinput} \newline
$
\end{center}
\end{linenomath}

\section{Quaternion Smooth Interpolation Between Quaternions}
\begin{linenomath}
$
Q_\textrm{initial} = Q_\textrm{Unit initial} \newline
Q_\textrm{final} = Q_\textrm{Unit final} \newline
\newline
D_\textrm{dot} = Q_\textrm{initial} \cdot Q_\textrm{final} \newline
\newline
\newline
Q_\textrm{initial} = \begin{cases}
    Q_\textrm{initial} = Q_\textrm{initial(additive inverse)}, & \text{if $D_\textrm{dot}<0$}.\\
     \hspace{1ex}Q_\textrm{initial}, & \text{otherwise}.\\
\end{cases}
\newline
\newline
\newline
D_\textrm{dot}=|D_\textrm{dot}|\newline
\newline
D_\textrm{dot}=\begin{cases}
    \hspace{1ex}1, & \text{if $D_\textrm{dot}>1$}.\\
     \hspace{1ex}D_\textrm{dot}, & \text{otherwise}.\\
\end{cases}
\newline
\newline
\newline
\theta = arccos(D_\textrm{dot}) \times ratio\\
\newline
Q_\textrm{orthonomal} = Q_\textrm{final} - Q_\textrm{initial} \times D_\textrm{dot}\\
Q_\textrm{output} = Q_{initial} \times cos(\theta) + Q_\textrm{orthonomal} \times sin(\theta)\newline
\newline
\newline
\newline
$
\end{linenomath}


\section{Quadcopter Combined Thrust Vector}
$
Q_\textrm{change} =  ( \frac{2  \times (Q_\textrm{target} - Q_\textrm{current}) \times Q_\textrm{current conjugate}}{dT} ) \\
\\
V_\textrm{Xchange} = Q_\textrm{Xchange}\\
V_\textrm{Ychange} = Q_\textrm{Ychange}\\
V_\textrm{Zchange} = Q_\textrm{Zchange}\\
\\
V_\textrm{RotationOutput} = FeedbackController_\textrm{rotation}.Calculate(0, V_\textrm{change})\\
V_\textrm{PositionOutput} = FeedbackController_\textrm{position}.Calculate(0, V_\textrm{CurrentPosition} - V_\textrm{TargetPosition})\\
\\
V_\textrm{YThrusterBOutput} = -V_\textrm{XRotationOutput} + V_\textrm{ZRotationOutput} - V_\textrm{YRotationOutput} \\
V_\textrm{YThrusterCOutput} = -V_\textrm{XRotationOutput} - V_\textrm{ZRotationOutput} + V_\textrm{YRotationOutput} \\
V_\textrm{YThrusterDOutput} = \hspace{2ex}V_\textrm{XRotationOutput} - V_\textrm{ZRotationOutput} - V_\textrm{YRotationOutput} \\
V_\textrm{YThrusterEOutput} = \hspace{2ex}V_\textrm{XRotationOutput} + V_\textrm{ZRotationOutput} + V_\textrm{YRotationOutput} \\
\\
V_\textrm{HoverAngles} = RotationToHoverAngles(Q_\textrm{CurrentRotation})\\
\\
V_\textrm{PositionOutput} = CalculateRotationOffset(Q_\textrm{CurrentRotation}).RotateVector(V_\textrm{PositionOutput})\\
\\
V_\textrm{XPositionOutput} = V_\textrm{XPositionOutput} + V_\textrm{ZHoverAngles}\\
V_\textrm{ZPositionOutput} = V_\textrm{ZPositionOutput} - V_\textrm{XHoverAngles}\\
\\
V_\textrm{ThrusterBOutput} = V_\textrm{ThrusterBOutput} + V_\textrm{PositionOutput}\\
V_\textrm{ThrusterCOutput} = V_\textrm{ThrusterCOutput} + V_\textrm{PositionOutput}\\
V_\textrm{ThrusterDOutput} = V_\textrm{ThrusterDOutput} + V_\textrm{PositionOutput}\\
V_\textrm{ThrusterEOutput} = V_\textrm{ThrusterEOutput} + V_\textrm{PositionOutput}
$


\section{Quadcopter Thruster Position Calculation}
$
V_\textrm{ThrusterBPosition} = Q_\textrm{CurrentRotation}.RotateVector(V_\textrm{ThrusterBOffset}) + V_\textrm{TargetPosition}\\
V_\textrm{ThrusterCPosition} = Q_\textrm{CurrentRotation}.RotateVector(V_\textrm{ThrusterCOffset}) + V_\textrm{TargetPosition}\\
V_\textrm{ThrusterDPosition} = Q_\textrm{CurrentRotation}.RotateVector(V_\textrm{ThrusterDOffset}) + V_\textrm{TargetPosition}\\
V_\textrm{ThrusterEPosition} = Q_\textrm{CurrentRotation}.RotateVector(V_\textrm{ThrusterEOffset}) + V_\textrm{TargetPosition}
$


\section{Quadcopter Hover Angle Calculation}
$
DA_\textrm{Direction} = RotationMatrix.RotateVector(EA_\textrm{rotate} (0, -90, 0), DA_\textrm{Direction} )\\
\newline
DA_\textrm{Direction} = RotationMatrix.RotateVector(EA_\textrm{rotate} (0, DA_\textrm{Rotation}, 0), DA_\textrm{Direction} )\\
\newline
D_\textrm{InnerJoint} = RadiansToDegrees( arcsin(D_\textrm{DirectionVectorZ}) )\\
D_\textrm{OuterJoint} = RadiansToDegrees( arctan2(D_\textrm{DirectionVectorX}, D_\textrm{DirectionVectorY}) )\\
$


\section{Quadcopter Estimate Position}
$
V_\textrm{TBThrust} = Vector(0, ThrustBOutputY, 0)\\
V_\textrm{TCThrust} = Vector(0, ThrustCOutputY, 0)\\
V_\textrm{TDThrust} = Vector(0, ThrustDOutputY, 0)\\
V_\textrm{TEThrust} = Vector(0, ThrustEOutputY, 0)\\
\newline
Q_\textrm{TBR} = EA(ThrustBOutput.X, 0, -ThrustBOutput.Z)\\
Q_\textrm{TCR} = EA(ThrustCOutput.X, 0, -ThrustCOutput.Z)\\
Q_\textrm{TDR} = EA(ThrustDOutput.X, 0, -ThrustDOutput.Z)\\
Q_\textrm{TER} = EA(ThrustEOutput.X, 0, -ThrustEOutput.Z)\\
\newline
V_\textrm{TBThrust} = Q_\textrm{TBR}.RotateVector( TBThrust )\\
V_\textrm{TCThrust} = Q_\textrm{TCR}.RotateVector( TCThrust )\\
V_\textrm{TDThrust} = Q_\textrm{TDR}.RotateVector( TDThrust )\\
V_\textrm{TEThrust} = Q_\textrm{TER}.RotateVector( TEThrust )\\
\newline
V_\textrm{ThrustSum} = V_\textrm{TBThrust} + V_\textrm{TCThrust} + V_\textrm{TDThrust} + V_\textrm{TEThrust}\\
V_\textrm{ThrustSum} = Q_\textrm{current}.RotateVector( V_\textrm{ThrustSum} )\\
\newline
V_\textrm{XDragForce} = D_\textrm{AirDensity} \times D_\textrm{XCurrentVelocity}^2 \times D_\textrm{DragCoefficient} \times Sign ( XCurrentVelocity ) \\
V_\textrm{YDragForce} = D_\textrm{AirDensity} \times D_\textrm{YCurrentVelocity}^2 \times D_\textrm{DragCoefficient} \times Sign ( YCurrentVelocity ) \\
V_\textrm{ZDragForce} = D_\textrm{AirDensity} \times D_\textrm{ZCurrentVelocity}^2 \times D_\textrm{DragCoefficient} \times Sign ( ZCurrentVelocity ) \\
\newline
V_\textrm{CurrentAcceleration} = V_\textrm{ThrustSum} + V_\textrm{WorldAcceleration}\\
V_\textrm{CurrentVelocity} = V_\textrm{CurrentVelocity} + V_\textrm{CurrentAcceleration} \times D_\textrm{TimeDerivative} \\
V_\textrm{CurrentPosition} = V_\textrm{CurrentPosition} + V_\textrm{CurrentVelocity} \times D_\textrm{TimeDerivative} \\
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
$


\section{Quadcopter Estimate Rotation}
$
V_\textrm{TB} = V_\textrm{TBThrustVector}\\
V_\textrm{TC} = V_\textrm{TCThrustVector}\\
V_\textrm{TD} = V_\textrm{TDThrustVector}\\
V_\textrm{TE} = V_\textrm{TEThrustVector}\\
\newline
V_\textrm{TB} = Q_\textrm{CurrentRotation}.RotateVector( TB )\\
V_\textrm{TC} = Q_\textrm{CurrentRotation}.RotateVector( TC )\\
V_\textrm{TD} = Q_\textrm{CurrentRotation}.RotateVector( TD )\\
V_\textrm{TE} = Q_\textrm{CurrentRotation}.RotateVector( TE )\\
\newline
D_\textrm{Torque} = D_\textrm{ArmLength} \times sin( 180 - D_\textrm{ArmAngle} )\\
\newline
V_\textrm{XAngularAcceleration} \hspace{2ex}= ( \hspace{2ex}V_\textrm{TBY} + V_\textrm{TCY} - V_\textrm{TDY} - V_\textrm{TEY} ) \times D_\textrm{Torque}\\
V_\textrm{YAngularAcceleration} \hspace{2ex}= ( \hspace{2ex}V_\textrm{TBX} + V_\textrm{TCX} - V_\textrm{TDX} - V_\textrm{TEY} ) \times D_\textrm{Torque}\\
V_\textrm{YAngularAcceleration}                     += ( \hspace{2ex}V_\textrm{TBZ} - V_\textrm{TCZ} - V_\textrm{TDZ} + V_\textrm{TEZ} ) \times D_\textrm{Torque}\\
V_\textrm{ZAngularAcceleration} \hspace{2ex}= ( -V_\textrm{TBY} + V_\textrm{TCY} + V_\textrm{TDY} - V_\textrm{TEY} ) \times D_\textrm{Torque}\\
\newline
V_\textrm{XDragForce} = D_\textrm{AirDensity} \times D_\textrm{XAngularVelocity}^2 \times D_\textrm{DragCoefficient} \times Sign ( XAngularVelocity ) \\
V_\textrm{YDragForce} = D_\textrm{AirDensity} \times D_\textrm{YAngularVelocity}^2 \times D_\textrm{DragCoefficient} \times Sign ( YAngularVelocity ) \\
V_\textrm{ZDragForce} = D_\textrm{AirDensity} \times D_\textrm{ZAngularVelocity}^2 \times D_\textrm{DragCoefficient} \times Sign ( ZAngularVelocity ) \\
\newline
V_\textrm{DifferentialThrust} = V_\textrm{TB} + V_\textrm{TC} - V_\textrm{TD} - V_\textrm{TE}\\
V_\textrm{AngularAcceleration} = V_\textrm{AngularAcceleration} + V_\textrm{DifferentialThrust}\\
V_\textrm{AngularVelocity} = V_\textrm{AngularVelocity} + ( V_\textrm{AngularAcceleration} - V_\textrm{DragForce} ) \times D_\textrm{TimeDerivative}\\
Q_\textrm{AngularRotation} = \frac {V_\textrm{AngularVelocity} \times D_\textrm{TimeDerivative}} {2}\\
Q_\textrm{AngularPosition} = Q_\textrm{AngularPosition} + Q_\textrm{AngularRotation} \times Q_\textrm{AngularPosition}\\
$

\section{Quadcopter Calculate 3D Yaw}
$
V_\textrm{HoverRotation} = HoverAnglesFromQuaternion(Q_\textrm{CurrentRotation})\\
Q_\textrm{Hover} = EA(V_\textrm{HoverRotation})\\
Q_\textrm{Yaw3D} = Q_\textrm{Hover} \times Q_\textrm{CurrentRotation}.MultiplicativeInverse()\\
\newline
\newline
\newline
\newline
\newline
\newline
$

\section{Quadcopter Gimbal Locked Translation}
$
D_\textrm{Fade} = TriangleWaveGenerator(-90 \longrightarrow 90) \Longrightarrow (0 \longrightarrow 1)\\
D_\textrm{InverseFade} = 1 -  D_\textrm{fade}\\
D_\textrm{Rotation} = 45 \times D_\textrm{fade}\\
\newline
V_\textrm{RotatedControl} = Q_{Calculate3DYaw(CurrentRotation)}.RotateVector(V_\textrm{PositionFeedbackControlOutput})\\
\newline
D_\textrm{TBX} = D_\textrm{TBX} \times D_\textrm{InverseFade} + D_\textrm{RotatedControlX} \times D_\textrm{Fade} + D_\textrm{RotatedControlZ} \times D_\textrm{Fade}\\
D_\textrm{TCX} = D_\textrm{TCX} \times D_\textrm{InverseFade} + D_\textrm{RotatedControlX} \times D_\textrm{Fade} + D_\textrm{RotatedControlZ} \times D_\textrm{Fade}\\
D_\textrm{TDX} = D_\textrm{TDX} \times D_\textrm{InverseFade} + D_\textrm{RotatedControlX} \times D_\textrm{Fade} + D_\textrm{RotatedControlZ} \times D_\textrm{Fade}\\
D_\textrm{TEX} = D_\textrm{TEX} \times D_\textrm{InverseFade} + D_\textrm{RotatedControlX} \times D_\textrm{Fade} + D_\textrm{RotatedControlZ} \times D_\textrm{Fade}\\
\newline
D_\textrm{TBZ} = D_\textrm{TBZ} \times D_\textrm{InverseFade} +  D_\textrm{Rotation}\\
D_\textrm{TCZ} = D_\textrm{TCZ} \times D_\textrm{InverseFade} -  D_\textrm{Rotation}\\
D_\textrm{TDZ} = D_\textrm{TDZ} \times D_\textrm{InverseFade} +  D_\textrm{Rotation}\\
D_\textrm{TEZ} = D_\textrm{TEZ} \times D_\textrm{InverseFade} -  D_\textrm{Rotation}\\
\newline
D_\textrm{PostionControlX} = D_\textrm{PostionControlX} \times D_\textrm{InverseFade}\\
D_\textrm{PostionControlZ} = D_\textrm{PostionControlZ} \times D_\textrm{InverseFade}\\
$



\section{ADRC}
$
D_\textrm{Amplificiation}\\
D_\textrm{Damping}\\
D_\textrm{Plant}\\
P_\textrm{PID}\\
D_\textrm{PrecisionModifier}\\
\newline
D_\textrm{Precision} = D_\textrm{TimeDerivative} \times D_\textrm{PrecisionModifier}
\newline
O_\textrm{CurrentOutput} = (P_\textrm{PID}.Calculate(D_\textrm{SetPoint}, D_\textrm{ProcessVariable}, D_\textrm{TimeDerivate}), O_\textrm{PreviousOutput} )\\
\newline
S_\textrm{State} = ESO_\textrm{ExtendedStateObserver}.Observe(D_\textrm{TimeDerivative}, O_\textrm{CurrentOutput}, D_\textrm{Plant}, D_\textrm{ProcessVariable})\\
\newline
D_\textrm{PreviousOutput} = D_\textrm{CurrentOutput}\\
D_\textrm{CurrentOutput} = NLC_\textrm{NonlinearCombiner}.Combine(O_\textrm{CurrentOutput}, D_\textrm{Plant}, S_\textrm{State}, D_\textrm{Precision})\\
\newline
\newline
\newline
\newline
$

\section{Setpoint Jump Prevention}
$
D_\textrm{Amp2Prec} = D_\textrm{Amplification}^2 \times D_\textrm{Precision}\\
D_\textrm{PrecTD} = D_\textrm{Precision} \times D_\textrm{TargetDerivative}\\
D_\textrm{TargetPrecTD} = D_\textrm{Target} + D_\textrm{PrecTD}\\
\newline
D_\textrm{A1} = \sqrt{D_\textrm{Amp2Prec} \times (D_\textrm{Amp2Prec} + (8 \times |D_\textrm{TargetPrecTD}|))}\\
\newline
D_\textrm{A2} =\frac{ D_\textrm{PrecTD} + Sign(D_\textrm{TargetPrecTD}) \times (D_\textrm{A1} - D_\textrm{Amp2Prec})} {2}\\
\newline
D_\textrm{SignTargetPrecTD} = \frac{Sign(D_\textrm{TargetPrecTD} + D_\textrm{Amp2Prec}) - Sign(D_\textrm{TargetPrecTD} - D_\textrm{Amp2Prec})} {2}
\newline
\newline
D_\textrm{A} = (D_\textrm{PrecTD} + D_\textrm{TargetPrecTD} - D_\textrm{A2}) \times D_\textrm{SignTargetPrecTD} + D_\textrm{A2}\\
\newline
D_\textrm{SignA} = \frac{Sign(D_\textrm{A} + D_\textrm{Amp2Prec}) - Sign(D_\textrm{A} - D_\textrm{Amp2Prec})} {2}
\newline
\newline
D_\textrm{SetpointJumpPrevention} = -D_\textrm{Amplification} \times (\frac{D_\textrm{A}}{D_\textrm{Amp2Prec}})- Sign(D_\textrm{A}) \times D_\textrm{SignA} - D_\textrm{Amplification} \times Sign(D_\textrm{A})\\
$

\section{Nonlinear Combiner}
$
D_\textrm{EstimationE1} = O_\textrm{CurrentOutput} - S_\textrm{StateZ1}\\
D_\textrm{EstimationE2} = O_\textrm{PreviousOutput} - S_\textrm{StateZ2}\\
D_\textrm{NominalControlSignal} = SetPointJumpPrevention(D_\textrm{Target}, D_\textrm{TargetDerivate}, D_\textrm{Amplificiation}, D_\textrm{Precision})\\
\newline
D_\textrm{Combine} = \frac{D_\textrm{NominalControlSignal} + S_\textrm{StateZ3}} {D_\textrm{Plant}}\\
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
$

\section{Extended State Observer}
$
S_\textrm{Gain1} = 1\\
\newline
S_\textrm{Gain2} = \frac{1} {2 \times dT^{0.5}}\\
\newline
S_\textrm{Gain3} = \frac{2} {25 \times dT^{1.2}}\\
\newline
\newline
D_\textrm{E} = D_\textrm{StateZ1} - D_\textrm{ProcessVariable}\\
D_\textrm{FE} = NonlinearFunction(D_\textrm{E}, 0.5, dT)\\
D_\textrm{FE1} = NonlinearFunction(D_\textrm{E}, 0.25, dT)\\
\newline
S_\textrm{StateZ1} = S_\textrm{StateZ1} + (dT \times S_\textrm{StateZ2}) - (S_\textrm{GainZ1} \times D_\textrm{E})\\
S_\textrm{StateZ2} = S_\textrm{StateZ2} + (dT \times (S_\textrm{StateZ3} + (D_\textrm{Plant} \times D_\textrm{Output}))) - (S_\textrm{GainZ2} \times D_\textrm{FE})\\
S_\textrm{StateZ3} = S_\textrm{StateZ3} - S_\textrm{GainZ3} \times D_\textrm{FE1}\\
$

\section{Nonlinear Function}
$
 Output = \begin{cases}
   \frac{ \eta } { \delta^{(1 - \alpha)} }, & \text{if $|\eta| \le \delta$}.\\
   |\eta|^{\alpha} \times Sign(\eta), & \text{otherwise}.\\
\end{cases}
$


\section{Axis-Angle to Quaternion}
$
D_\textrm{Rotation} = \frac{ AA_\textrm{AxisAngleRotation} \times \pi} {180}\\
\newline
D_\textrm{Scale} = sin( \frac{D_\textrm{Rotation}} {2} )\\
\newline
Q_\textrm{W} = cos( \frac{D_\textrm{Rotation}} {2} )\\
Q_\textrm{X} = AA_\textrm{AxisAngleX} \times D_\textrm{Scale}\\
Q_\textrm{Y} = AA_\textrm{AxisAngleY} \times D_\textrm{Scale}\\
Q_\textrm{Z} = AA_\textrm{AxisAngleZ} \times D_\textrm{Scale}\\
\newline
\newline
\newline
\newline
\newline
\newline
\newline
$

\section{Quaternion to Axis-Angle}
$
AA_\textrm{Rotation} = 2 \times acos( Q_\textrm{W} )\\
\newline
D_\textrm{QuaternionCheck} = \sqrt{ 1 - Q_\textrm{W}^2 }\\
\newline
\newline
AA_\textrm{AxisX} = \begin{cases}
   \frac{ Q_\textrm{X} } {D_\textrm{QuaternionCheck}}, & \text{if $D_\textrm{QuaternionCheck} \ge 0.001$}.\\
   0, & \text{otherwise}.\\
\end{cases}\\
AA_\textrm{AxisY} = \begin{cases}
   \frac{ Q_\textrm{Y} } {D_\textrm{QuaternionCheck}}, & \text{if $D_\textrm{QuaternionCheck} \ge 0.001$}.\\
   0, & \text{otherwise}.\\
\end{cases}\\
AA_\textrm{AxisZ} = \begin{cases}
   \frac{ Q_\textrm{Z} } {D_\textrm{QuaternionCheck}}, & \text{if $D_\textrm{QuaternionCheck} \ge 0.001$}.\\
   0, & \text{otherwise}.\\
\end{cases}\\
$



\section{Direction-Angle to Quaternion}
$
V_\textrm{Right} = Vector(1, 0, 0)\\
V_\textrm{Up} = Vector(0, 1, 0)\\
V_\textrm{Forward} = Vector(0, 0, 1)\\
\newline
V_\textrm{RotatedUp} = DA_\textrm{DirectionAngleDirection}\\
\newline
Q_\textrm{Rotation} = QuaternionFromDirectionVectors(V_\textrm{Up}, V_\textrm{RotatedUp})\\
\newline
V_\textrm{RotatedRight} = RM_\textrm{RotationMatrix}.Rotate( Vector(0, -DA_\textrm{DirectionAngleRotation}, 0), V_\textrm{Right})\\
V_\textrm{RotatedForward} = RM_\textrm{RotationMatrix}.Rotate( Vector(0, -DA_\textrm{DirectionAngleRotation}, 0), V_\textrm{Forward})\\
\newline
V_\textrm{RotatedRight} = Q_\textrm{Rotation}.RotateVector(V_\textrm{RotatedRight})\\
V_\textrm{RotatedForward} = Q_\textrm{Rotation}.RotateVector(V_\textrm{RotatedForward})\\
\newline
Q_\textrm{Quaternion} = RMToQuaternion(RotationMatrix(V_\textrm{RotatedRight}, V_\textrm{RotatedUp}, V_\textrm{RotatedForward}))\\
\newline
\newline
\newline
\newline
\newline
\newline
\newline
$

\section{Quaternion to Direction-Angle}
$
V_\textrm{Up} = Vector(0, 1, 0)\\
V_\textrm{Right} = Vector(1, 0, 0)\\
V_\textrm{RotatedUp} = Q_\textrm{Quaternion}.RotateVector(V_\textrm{Up})\\
V_\textrm{RotatedRight} = Q_\textrm{Quaternion}.RotateVector(V_\textrm{Right})\\
\newline
Q_\textrm{Rotation} = QuaternionFromDirectionVectors(V_\textrm{Up}, V_\textrm{RotateUp})\\
\newline
V_\textrm{RightCompensated} = Q_\textrm{Rotation}.UnrotateVector(V_\textrm{RotatedRight})\\
\newline
D_\textrm{RightAngle} = \frac{ atan2(D_\textrm{RightZ}, D_\textrm{RightX}) \times \pi} {180}\\
D_\textrm{RightRotatedAngle} = \frac{ atan2(D_\textrm{RightCompensatedZ}, D_\textrm{RightCompensatedX}) \times \pi} {180}\\
\newline
DA_\textrm{Rotation} = D_\textrm{RightAngle} - D_\textrm{RightRotateAngle}\\
DA_\textrm{Direction} = V_\textrm{RotatedUp}\\
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
$


\section{Rotation Matrix to Quaternion}
$
D_\textrm{MatrixTrace} = V_\textrm{XAxisX} + V_\textrm{YAxisY} + V_\textrm{ZAxisZ}\\
\newline
D_\textrm{Square} = \begin{cases}
   \sqrt{1 + MatrixTrace} \times 2, & \text{if $D_\textrm{MatrixTrace}$} > 0.\\
   \sqrt{1 + D_\textrm{XAxisX} - D_\textrm{YAxisY} - D_\textrm{ZAxisZ}} \times 2, & \text{if $D_\textrm{XAxisX} > D_\textrm{YAxisY}$ and $D_\textrm{XAxisX} > D_\textrm{ZAxisZ}$}.\\
   \sqrt{1 + D_\textrm{YAxisY} - D_\textrm{XAxisX} - D_\textrm{ZAxisZ}} \times 2, & \text{if $D_\textrm{YAxisY} > D_\textrm{ZAxisZ}$}.\\
   \sqrt{1 + D_\textrm{ZAxisZ} - D_\textrm{XAxisX} - D_\textrm{YAxisY}} \times 2, & \text{otherwise}.\\
\end{cases}\\
\newline
Q_\textrm{W} = \begin{cases}
   \frac{D_\textrm{Square}}{4}, & \text{if $D_\textrm{MatrixTrace}$} > 0.\\
   \frac{D_\textrm{ZAxisY} - D_\textrm{YAxisZ}}{D_\textrm{Square}}, & \text{if $D_\textrm{XAxisX} > D_\textrm{YAxisY}$ and $D_\textrm{XAxisX} > D_\textrm{ZAxisZ}$}.\\
   \frac{D_\textrm{XAxisZ} - D_\textrm{ZAxisX}}{D_\textrm{Square}}, & \text{if $D_\textrm{YAxisY} > D_\textrm{ZAxisZ}$}.\\
   \frac{D_\textrm{YAxisX} - D_\textrm{XAxisY}}{D_\textrm{Square}}, & \text{otherwise}.\\
\end{cases}\\
\newline
Q_\textrm{X} = \begin{cases}
   \frac{D_\textrm{ZAxisY} - D_\textrm{YAxisZ}}{D_\textrm{Square}}, & \text{if $D_\textrm{MatrixTrace}$} > 0.\\
   \frac{D_\textrm{Square}}{4}, & \text{if $D_\textrm{XAxisX} > D_\textrm{YAxisY}$ and $D_\textrm{XAxisX} > D_\textrm{ZAxisZ}$}.\\
   \frac{D_\textrm{XAxisY} - D_\textrm{YAxisX}}{D_\textrm{Square}}, & \text{if $D_\textrm{YAxisY} > D_\textrm{ZAxisZ}$}.\\
   \frac{D_\textrm{XAxisZ} - D_\textrm{ZAxisX}}{D_\textrm{Square}}, & \text{otherwise}.\\
\end{cases}\\
\newline
Q_\textrm{Y} = \begin{cases}
   \frac{D_\textrm{XAxisZ} - D_\textrm{ZAxisX}}{D_\textrm{Square}}, & \text{if $D_\textrm{MatrixTrace}$} > 0.\\
   \frac{D_\textrm{XAxisY} - D_\textrm{YAxisX}}{D_\textrm{Square}}, & \text{if $D_\textrm{XAxisX} > D_\textrm{YAxisY}$ and $D_\textrm{XAxisX} > D_\textrm{ZAxisZ}$}.\\
   \frac{D_\textrm{Square}}{4}, & \text{if $D_\textrm{YAxisY} > D_\textrm{ZAxisZ}$}.\\
   \frac{D_\textrm{YAxisZ} - D_\textrm{ZAxisY}}{D_\textrm{Square}}, & \text{otherwise}.\\
\end{cases}\\
\newline
Q_\textrm{Z} = \begin{cases}
   \frac{D_\textrm{YAxisZ} - D_\textrm{ZAxisY}}{D_\textrm{Square}}, & \text{if $D_\textrm{MatrixTrace}$} > 0.\\
   \frac{D_\textrm{XAxisZ} - D_\textrm{ZAxisX}}{D_\textrm{Square}}, & \text{if $D_\textrm{XAxisX} > D_\textrm{YAxisY}$ and $D_\textrm{XAxisX} > D_\textrm{ZAxisZ}$}.\\
   \frac{D_\textrm{YAxisZ} - D_\textrm{ZAxisY}}{D_\textrm{Square}}, & \text{if $D_\textrm{YAxisY} > D_\textrm{ZAxisZ}$}.\\
   \frac{D_\textrm{Square}}{4}, & \text{otherwise}.\\
\end{cases}\\
\newline
\newline
Q_\textrm{WXYZ} = Conjugate(Q_\textrm{WXYZ})\\ 
$

\section{Quaternion to Rotation Matrix}
$
V_\textrm{Right} = Vector(1, 0, 0)\\
V_\textrm{Up} = Vector(0, 1, 0)\\
V_\textrm{Forward} = Vector(0, 0, 1)\\
\newline
RM_\textrm{XAxis} = Q_\textrm{Rotation}.RotateVector(V_\textrm{Right})\\
RM_\textrm{YAxis} = Q_\textrm{Rotation}.RotateVector(V_\textrm{Up})\\
RM_\textrm{ZAxis} = Q_\textrm{Rotation}.RotateVector(V_\textrm{Forward})\\
$

\section{Direction Vectors to Quaternion}
$
V_\textrm{XAxis} = Vector(1, 0, 0)\\
V_\textrm{YAxis} = Vector(0, 1, 0)\\
D_\textrm{Dot} = V_\textrm{Initial} \dot V_\textrm{Final}\\
\newline
C_\textrm{Cross} = \begin{cases}
   V_\textrm{XAxis} \times V_\textrm{Initial}, & \text{if $D_\textrm{Dot}$} < -0.999.\\
   Vector(0, 0, 0), & \text{if $D_\textrm{Dot} > 0.999$}.\\
   V_\textrm{Initial} \times V_\textrm{Final}, & \text{otherwise}.\\
\end{cases}\\
\newline
C_\textrm{Cross} = \begin{cases}
   V_\textrm{YAxis} \times V_\textrm{Initial}, & \text{if $D_\textrm{CrossLength}$} < 0.001.\\
\end{cases}\\
\newline
AA_\textrm{AxisAngle} = AxisAngle(\pi, V_\textrm{Cross})
\newline
Q_\textrm{W} = \begin{cases}
   D_\textrm{AxisAngleRotation}, & \text{if $D_\textrm{Dot}$} < -0.999.\\
   1, & \text{if $D_\textrm{Dot}$} > 0.999.\\
   1 + D_\textrm{Dot}, & \text{otherwise}.\\
\end{cases}\\
\newline
Q_\textrm{X} = \begin{cases}
   D_\textrm{AxisAngleAxisX}, & \text{if $D_\textrm{Dot}$} < -0.999.\\
   0, & \text{if $D_\textrm{Dot}$} > 0.999.\\
   D_\textrm{CrossX}, & \text{otherwise}.\\
\end{cases}\\
\newline
Q_\textrm{Y} = \begin{cases}
   D_\textrm{AxisAngleAxisY}, & \text{if $D_\textrm{Dot}$} < -0.999.\\
   0, & \text{if $D_\textrm{Dot}$} > 0.999.\\
   D_\textrm{CrossY}, & \text{otherwise}.\\
\end{cases}\\
\newline
Q_\textrm{Z} = \begin{cases}
   D_\textrm{AxisAngleAxisZ}, & \text{if $D_\textrm{Dot}$} < -0.999.\\
   0, & \text{if $D_\textrm{Dot}$} > 0.999.\\
   D_\textrm{CrossZ}, & \text{otherwise}.\\
\end{cases}\\
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
$

\section{Euler Angles to Quaternion}
$
D_\textrm{Rotating} = D_\textrm{EulerX}\\
\newline
D_\textrm{EulerX} = \begin{cases}
   D_\textrm{EulerZ}, & \text{if $F_\textrm{Frame} = F_\textrm{Rotating}$}\\
   D_\textrm{EulerX}, & \text{otherwise}.\\
\end{cases}\\
\newline
D_\textrm{EulerZ} = \begin{cases}
   D_\textrm{Rotating}, & \text{if $F_\textrm{Frame} = F_\textrm{Rotating}$}\\
   D_\textrm{EulerZ}, & \text{otherwise}.\\
\end{cases}\\
\newline
D_\textrm{EulerY} = \begin{cases}
   -D_\textrm{EulerY}, & \text{if $P_\textrm{AxisPermutation} = P_\textrm{Odd}$}\\
   D_\textrm{EulerY}, & \text{otherwise}.\\
\end{cases}\\
\newline
\newline
D_\textrm{SineX} = sin(\frac{D_\textrm{EulerX}}{2})\\
D_\textrm{SineY} = sin(\frac{D_\textrm{EulerY}}{2})\\
D_\textrm{SineZ} = sin(\frac{D_\textrm{EulerZ}}{2})\\
\newline
D_\textrm{CosineX} = cos(\frac{D_\textrm{EulerX}}{2})\\
D_\textrm{CosineY} = cos\frac{D_\textrm{EulerY}}{2})\\
D_\textrm{CosineZ} = cos\frac{D_\textrm{EulerZ}}{2})\\
\newline
\newline
D_\textrm{CC} = D_\textrm{CosineX} \times D_\textrm{CosineZ}\\
D_\textrm{CS} = D_\textrm{CosineX} \times D_\textrm{SineZ}\\
D_\textrm{SC} = D_\textrm{SineX} \times D_\textrm{CosineZ}\\
D_\textrm{SS} = D_\textrm{SineX} \times D_\textrm{SineZ}\\
\newline
Q_\textrm{W} = \begin{cases}
   D_\textrm{CosineY} \times (D_\textrm{CC} - D_\textrm{SS}), & \text{if $A_\textrm{AxisRepetition} = A_\textrm{Yes}$}\\
   D_\textrm{CosineY} \times D_\textrm{CC} + D_\textrm{SineY} \times D_\textrm{SS}, & \text{otherwise}.\\
\end{cases}\\
\newline
Q_\textrm{X} = \begin{cases}
   D_\textrm{CosineY} \times (D_\textrm{CS} + D_\textrm{SC}), & \text{if $A_\textrm{AxisRepetition} = A_\textrm{Yes}$}\\
   D_\textrm{CosineY} \times D_\textrm{SC} - D_\textrm{SineY} \times D_\textrm{CS}, & \text{otherwise}.\\
\end{cases}\\
\newline
Q_\textrm{Y} = \begin{cases}
   D_\textrm{SineY} \times (D_\textrm{CC} + D_\textrm{SS}), & \text{if $A_\textrm{AxisRepetition} = A_\textrm{Yes}$}\\
   D_\textrm{CosineY} \times D_\textrm{SS} + D_\textrm{SineY} \times D_\textrm{CC}, & \text{otherwise}.\\
\end{cases}\\
\newline
Q_\textrm{Z} = \begin{cases}
   D_\textrm{SineY} \times (D_\textrm{CS} - D_\textrm{SC}), & \text{if $A_\textrm{AxisRepetition} = A_\textrm{Yes}$}\\
   D_\textrm{CosineY} \times D_\textrm{CS} - D_\textrm{SineY} \times D_\textrm{SC}, & \text{otherwise}.\\
\end{cases}\\
\newline
Q_\textrm{WXYZ} = Q_\textrm{WXYZ}.Permutate(V_\textrm{Permutation})\\
\newline
Q_\textrm{Y} = \begin{cases}
   -Q_\textrm{Y}, & \text{if $P_\textrm{AxisPermutation} = P_\textrm{Odd}$}\\
   Q_\textrm{Y}, & \text{otherwise}.\\
\end{cases}\\
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
$


\section{Quaternion to Euler Angles}
$
D_\textrm{Norm} = D_\textrm{QuaternionNormal}\\
D_\textrm{Scale} = \begin{cases}
   \frac{2}{D_\textrm{Norm}}, & \text{if $D_\textrm{Norm}$} > 0\\
   0, & \text{otherwise}.\\
\end{cases}\\
\newline
V_\textrm{SB} = Vector(Q_\textrm{X} \times D_\textrm{Scale}, Q_\textrm{Y} \times D_\textrm{Scale}, Q_\textrm{Z} \times D_\textrm{Scale})\\
V_\textrm{W} = Vector(Q_\textrm{W} \times SB_\textrm{X}, Q_\textrm{W} \times SB_\textrm{Y}, Q_\textrm{W} \times SB_\textrm{Z} )\\
V_\textrm{X} = Vector(Q_\textrm{X} \times SB_\textrm{X}, Q_\textrm{X} \times SB_\textrm{Y}, Q_\textrm{X} \times SB_\textrm{Z} )\\
V_\textrm{Y} = Vector(0, Q_\textrm{Y} \times SB_\textrm{Y}, Q_\textrm{Y} \times SB_\textrm{Z} )\\
V_\textrm{Z} = Vector(0, 0, Q_\textrm{Z} \times SB_\textrm{Z} )\\
\newline
V_\textrm{XAxis} = Vector(1 - D_\textrm{YY} + D_\textrm{ZZ}, D_\textrm{XY} - D_\textrm{WZ}, D_\textrm{XZ} + D_\textrm{WY})\\
V_\textrm{YAxis} = Vector(D_\textrm{XY} + D_\textrm{WZ}, 1- D_\textrm{XX} - D_\textrm{ZZ}, D_\textrm{YZ} - D_\textrm{WX})\\
V_\textrm{ZAxis} = Vector(D_\textrm{XZ} - D_\textrm{WY}, D_\textrm{YZ} - D_\textrm{WX}, 1 - D_\textrm{XX} + D_\textrm{YY})\\
\newline
RM_\textrm{RotationMatrix} = RotationMatrix(V_\textrm{XAxis}, V_\textrm{YAxis}, V_\textrm{ZAxis})\\
\newline
D_\textrm{SineY} = \sqrt{(D_\textrm{XY}^2) + (D_\textrm{XZ}^2)}\\
D_\textrm{CosineY} = \sqrt{(D_\textrm{XX}^2) + (D_\textrm{YX}^2)}\\
\newline
D_\textrm{EAX} = \begin{cases}
   atan2(D_\textrm{XY}, D_\textrm{XZ}), & \text{if Initial Axis is repeated and}  D_\textrm{SineY} > 32 \times D_\textrm{Epsilon}\\
   atan2(-D_\textrm{YZ}, D_\textrm{YY}), & \text{if Initial Axis is repeated and}  D_\textrm{SineY} \le 32 \times D_\textrm{Epsilon}\\
   atan2(D_\textrm{ZY}, D_\textrm{ZZ}), & \text{if Initial Axis is not repeated and}  D_\textrm{SineY} > 32 \times D_\textrm{Epsilon}\\
   atan2(-D_\textrm{YZ}, D_\textrm{YY}), & \text{if Initial Axis is not repeated and}  D_\textrm{SineY} \le 32 \times D_\textrm{Epsilon}\\
\end{cases}\\
\newline
D_\textrm{EAY} = \begin{cases}
   atan2(D_\textrm{SineY}, D_\textrm{XX}), & \text{if Initial Axis is repeated}\\
   atan2(-D_\textrm{ZX}, D_\textrm{CosineY}), & \text{if Initial Axis is not repeated}\\
\end{cases}\\
\newline
D_\textrm{EAZ} = \begin{cases}
   atan2(D_\textrm{YX}, -D_\textrm{ZX}), & \text{if Initial Axis is repeated and}  D_\textrm{SineY} > 32 \times D_\textrm{Epsilon}\\
   0, & \text{if Initial Axis is repeated and}  D_\textrm{SineY} \le 32 \times D_\textrm{Epsilon}\\
   atan2(D_\textrm{YX}, D_\textrm{XX}), & \text{if Initial Axis is not repeated and}  D_\textrm{SineY} > 32 \times D_\textrm{Epsilon}\\
   0, & \text{if Initial Axis is not repeated and}  D_\textrm{SineY} \le 32 \times D_\textrm{Epsilon}\\
\end{cases}\\
\newline
D_\textrm{EAX} = \begin{cases}
    -D_\textrm{EAX}, & \text{if Axis Permutation is Odd}\\
\end{cases}
\newline
D_\textrm{EAY} = \begin{cases}
    -D_\textrm{EAY}, & \text{if Axis Permutation is Odd}\\
\end{cases}
\newline
D_\textrm{EAZ} = \begin{cases}
    -D_\textrm{EAZ}, & \text{if Axis Permutation is Odd}\\
\end{cases}
\newline
\newline
D_\textrm{TempX} = D_\textrm{EAX}\\
D_\textrm{EAX} = \begin{cases}
    D_\textrm{EAZ}, & \text{if Frame Taken is Rotating}\\
\end{cases}
\newline
D_\textrm{EAZ} = \begin{cases}
    D_\textrm{TempX}, & \text{if Frame Taken is Rotating}\\
\end{cases}
\newline
$


\section{Kalman Filter}
$
Array_\textrm{Dataset}.Add(D_\textrm{Datapoint})\\
\newline
\text{if  } I_\textrm{DatasetLength} > I_\textrm{Memory},\text{ }   Array_\textrm{Dataset}.RemoveLast()\\
\newline
D_\textrm{Sum} = \sum Array_\textrm{Dataset}\\
\newline
D_\textrm{Average} = \frac{D_\textrm{Sum}} {I_\textrm{Memory}} \\
\newline
D_\textrm{FilteredValue} = D_\textrm{KalmanGain} \times D_\textrm{Datapoint} + (1 - D_\textrm{KalmanGain}) \times D_\textrm{Average}\\
$



\section{Quaternion Kalman Filter}
$
Array_\textrm{Dataset}.Add(Q_\textrm{Datapoint})\\
\newline
\text{if  } I_\textrm{DatasetLength} > I_\textrm{Memory},\text{ }   Array_\textrm{Dataset}.RemoveLast()\\
\newline
Q_\textrm{Sum} = \sum Array_\textrm{Dataset}\\
\newline
Q_\textrm{Average} = \frac{Q_\textrm{Sum}} {I_\textrm{Memory}} \\
\newline
D_\textrm{FilteredValue} = SphericalInterpolation(Q_\textrm{Datapoint}, Q_\textrm{Average}, 1 - D_\textrm{KalmanGain})\\
$


\section{Finite Impulse Response Filter}
$
D_\textrm{Output} = f^\textrm{N} = \sum{Dataset_\textrm{N} \times Taps_\textrm{N}}\\
$


\section{FIR High-Pass Taps}
$
\lambda = \frac{\pi \times D_\textrm{CutFrequency} \times 2} {D_\textrm{SamplingRate}}\\
\newline
Taps_\textrm{N} = f^\textrm{N} (x) = \begin{cases}
    \frac{1 - (\lambda)} {\pi}, & \text{if } \frac{I_\textrm{N} - 1} {2} \text{ is 0}\\
    \frac{-sin(\frac{I_\textrm{N} - 1} {2} \times \lambda)} {\frac{I_\textrm{N} - 1} {2} \times \pi}, & \textrm{otherwise}\\
\end{cases}
$


\section{FIR Low-Pass Taps}
$
\lambda = \frac{\pi \times D_\textrm{CutFrequency} \times 2} {D_\textrm{SamplingRate}}\\
\newline
Taps_\textrm{N} = f^\textrm{N} (x) = \begin{cases}
    \frac{1 - (\lambda)} {\pi}, & \text{if } \frac{I_\textrm{N} - 1} {2} \text{ is 0}\\
    \frac{sin(\frac{I_\textrm{N} - 1} {2} \times \lambda)} {\frac{I_\textrm{N} - 1} {2} \times \pi}, & \textrm{otherwise}\\
\end{cases}
$


\section{FIR Band-Pass Taps}
$
\lambda = \frac{\pi \times D_\textrm{CutFrequency} \times 2} {D_\textrm{SamplingRate}}\\
\newline
\phi = \frac{\pi \times D_\textrm{SecondaryCutFrequency} \times 2} {D_\textrm{SamplingRate}}\\
\newline
Taps_\textrm{N} = f^\textrm{N} (x) = \begin{cases}
    \frac{\phi - (\lambda)} {\pi}, & \text{if } \frac{I_\textrm{N} - 1} {2} \text{ is 0}\\
    \frac{sin(\frac{I_\textrm{N} - 1} {2} \times \phi) - sin(\frac{I_\textrm{N} - 1} {2} \times \lambda)} {\frac{I_\textrm{N} - 1} {2} \times \pi}, & \textrm{otherwise}\\
\end{cases}
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
$

\section{Least Squares Regression}
$
D_\textrm{Output} = f^\textrm{N} \text{(X, Y, Target)}\\
\newline
D_\textrm{SumX} = \sum{ X_\textrm{N} }\\
D_\textrm{SumXX} = \sum{ (X_\textrm{N} \times X_\textrm{N}) }\\
D_\textrm{SumXY} = \sum{ (X_\textrm{N} \times Y_\textrm{N}) }\\
D_\textrm{SumY} = \sum{ Y_\textrm{N} }\\
D_\textrm{SumYY} = \sum{ (Y_\textrm{N} \times Y_\textrm{N}) }\\
\newline
D_\textrm{Denom} = X_\textrm{Size} \times D_\textrm{SumXX} - D_\textrm{SumX}^2\\
\newline
D_\textrm{Slope} = \begin{cases}
   \frac{X_\textrm{Size} \times D_\textrm{SumXY} - D_\textrm{SumX} \times D_\textrm{SumY}} {D_\textrm{Denom}}, & \text{if } D_\textrm{Denom} \text{ != 0} \\
   0, & \text{otherwise}\\
\end{cases}\\
\newline
D_\textrm{Intercept} = \begin{cases}
   \frac{D_\textrm{SumY} \times D_\textrm{SumXX} - D_\textrm{SumX} \times D_\textrm{SumXY}} {D_\textrm{Denom}}, & \text{if } D_\textrm{Denom} \text{ != 0} \\
   0, & \text{otherwise}\\
\end{cases}
\newline
\newline
D_\textrm{Output} = D_\textrm{Slope} \times D_\textrm{Target} + D_\textrm{Intercept}\\
$

\section{Cooley-Tukey Fast Fourier Transform}
$
I_\textrm{Flip} = \begin{cases}
   -1, & \text{if inverse transform}\\
    1, & \text{otherwise}\\
\end{cases}\\
B_\textrm{Continue} = \begin{cases}
    Continue, & \text{if } D_\textrm{DatasetLength} \ge 2\\
    Break, & \text{otherwise}\\
\end{cases}
\newline
\newline
ComplexArray_\textrm{Dataset} = Rearrange(ComplexArray_\textrm{Dataset})\\
ComplexArray_\textrm{Dataset} = FFT(ComplexArray_\textrm{Dataset},\frac{ D_\textrm{DatasetLength}} {2}, isInverse)\\
ComplexArray_\textrm{Dataset} = FFT(ComplexArray_\textrm{Dataset} + \frac{ D_\textrm{DatasetLength}} {2}, \frac{ D_\textrm{DatasetLength}} {2}, isInverse)\\
\newline
Complex_\textrm{Even} = f^\textrm{N}[N < \frac{ D_\textrm{DatasetLength}} {2}] = D_\textrm{Dataset}[N]\\
Complex_\textrm{Odd}  = f^\textrm{N}[N < \frac{ D_\textrm{DatasetLength}} {2}] = D_\textrm{Dataset}[N + \frac{ D_\textrm{DatasetLength}} {2}]\\
Complex_\textrm{Exp} = Complex(0, -2 \times \pi \times D_\textrm{Flip} \times N / D_\textrm{DatasetLength} )\\
Complex_\textrm{Twiddle} = f^\textrm{N}[N < \frac{ D_\textrm{DatasetLength}} {2}] = e^\textrm{Exp}\\
\newline
CA_\textrm{Dataset} = f^\textrm{N}[N < \frac{ D_\textrm{DatasetLength}} {2}] = C_\textrm{Even} + C_\textrm{Twiddle} \times C_\textrm{Odd}\\
CA_\textrm{Dataset} = f^\textrm{N}[N + \frac{ D_\textrm{DatasetLength}} {2} < D_\textrm{DatasetLength}] = C_\textrm{Even} - C\textrm{Twiddle} \times C_\textrm{Odd}\\
$

\section{FFT Rearrange Odd/Even}
$
ComplexArray_\textrm{Temp} = f^\textrm{N} [ N < \frac{D_\textrm{ InputLength}}{2} ] = ComplexArray_\textrm{Input}[N \times 2 + 1]\\
\newline
ComplexArray_\textrm{Input} = f^\textrm{N} [ N < \frac{D_\textrm{ InputLength}}{2} ] = ComplexArray_\textrm{Input}[N \times 2]\\
\newline
ComplexArray_\textrm{Input} = f^\textrm{N} [ N + \frac{D_\textrm{ InputLength}}{2} < D_\textrm{InputLength} ] = ComplexArray_\textrm{Temp}[N]\\
$

\section{FFT Scale Inverse}
$
ComplexArray_\textrm{N} = f^\textrm{N} = \Pi_\textrm{N} \frac{1} {D_\textrm{ComplexArrayLength}}\\
$


\end{document}