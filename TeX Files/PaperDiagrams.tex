\documentclass{article}
\usepackage{amsmath}
\usepackage{lineno}
\usepackage{mathtools}
\title{Q Multiplication}

\begin{document}


\section{Quaternion Multiplication}
\begin{linenomath}
\begin{center}
$
Q_\textrm{Wnew} = Q_\textrm{W1}(Q_\textrm{W2}) - Q_\textrm{X1}(Q_\textrm{X2}) - Q_\textrm{Y1}(Q_\textrm{Y2}) - Q_\textrm{Z1}(Q_\textrm{Z2}) \newline
Q_\textrm{Xnew} = Q_\textrm{W1}(Q_\textrm{X2}) - Q_\textrm{X1}(Q_\textrm{W2}) - Q_\textrm{Y1}(Q_\textrm{Z2}) - Q_\textrm{Z1}(Q_\textrm{Y2}) \newline
Q_\textrm{Ynew} = Q_\textrm{W1}(Q_\textrm{Y2}) - Q_\textrm{X1}(Q_\textrm{Z2}) - Q_\textrm{Y1}(Q_\textrm{W2}) - Q_\textrm{Z1}(Q_\textrm{X2}) \newline
Q_\textrm{Znew} = Q_\textrm{W1}(Q_\textrm{Z2}) - Q_\textrm{X1}(Q_\textrm{Y2}) - Q_\textrm{Y1}(Q_\textrm{X2}) - Q_\textrm{Z1}(Q_\textrm{W2}) \newline
$
\end{center}
\end{linenomath}



\section{Quaternion Division}
\begin{linenomath}
\begin{center}
$
Q_\textrm{Wnew} =  \hspace{1ex}Q_\textrm{W1}(Q_\textrm{W2}) + Q_\textrm{X1}(Q_\textrm{X2}) + Q_\textrm{Y1}(Q_\textrm{Y2}) + Q_\textrm{Z1}(Q_\textrm{Z2}) \newline
Q_\textrm{Xnew} = -Q_\textrm{W1}(Q_\textrm{X2}) + Q_\textrm{X1}(Q_\textrm{W2}) + Q_\textrm{Y1}(Q_\textrm{Z2}) - Q_\textrm{Z1}(Q_\textrm{Y2}) \newline
Q_\textrm{Ynew} = -Q_\textrm{W1}(Q_\textrm{Y2}) - Q_\textrm{X1}(Q_\textrm{Z2}) + Q_\textrm{Y1}(Q_\textrm{W2}) + Q_\textrm{Z1}(Q_\textrm{X2}) \newline
Q_\textrm{Znew} = -Q_\textrm{W1}(Q_\textrm{Z2}) + Q_\textrm{X1}(Q_\textrm{Y2}) - Q_\textrm{Y1}(Q_\textrm{X2}) + Q_\textrm{Z1}(Q_\textrm{W2}) \newline
$
\end{center}
\end{linenomath}


\section{Quaternion Conjugate}
\begin{linenomath}
\begin{center}
$
Q_\textrm{Wconjugate} =  \hspace{1ex}Q_\textrm{Winput}\newline
Q_\textrm{Xconjugate} =  -Q_\textrm{Xinput}\newline
Q_\textrm{Yconjugate} = -Q_\textrm{Yinput}\newline
Q_\textrm{Zconjugate} =  -Q_\textrm{Zinput}\newline
$
\end{center}
\end{linenomath}


\section{Quaternion Normal}
\begin{linenomath}
\begin{center}
$
Normal_\textrm{rational} = Q_W^2 + Q_X^2 + Q_Y^2 + Q_Z^2 \newline
$
\end{center}
\end{linenomath}


\section{Quaternion Multiplicative Inverse}
\begin{linenomath}
\begin{center}
$
Q_\textrm{reciprocal} = Q_\textrm{conjugate} Ã— \frac{1}{Q_\textrm{normal}} \newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
$
\end{center}
\end{linenomath}


\section{Quaternion Vector Rotation}
\begin{linenomath}
\begin{center}
$
Q_\textrm{Wbivector} =\hspace{1ex} 0 \newline
Q_\textrm{Xbivector} = V_X \newline
Q_\textrm{Ybivector} = V_Y \newline
Q_\textrm{Zbivector} = V_Z \newline
\newline
Q_\textrm{rotation} = Q_\textrm{current}(Q_\textrm{bivector})(Q_\textrm{reciprocal}) \newline
\newline
V_\textrm{Xrotated} = Q_\textrm{Xrotation} \newline
V_\textrm{Yrotated} = Q_\textrm{Yrotation} \newline
V_\textrm{Zrotated} = Q_\textrm{Zrotation} \newline
$
\end{center}
\end{linenomath}


\section{Quaternion Vector Rotation Removal}
\begin{linenomath}
\begin{center}
$
Q_\textrm{Wbivector} =\hspace{1ex} 0 \newline
Q_\textrm{Xbivector} = V_X \newline
Q_\textrm{Ybivector} = V_Y \newline
Q_\textrm{Zbivector} = V_Z \newline
\newline
Q_\textrm{rotation} = Q_\textrm{conjugate}(Q_\textrm{bivector})(Q_\textrm{reciprocal}) \newline
\newline
V_\textrm{Xrotated} = Q_\textrm{Xrotation} \newline
V_\textrm{Yrotated} = Q_\textrm{Yrotation} \newline
V_\textrm{Zrotated} = Q_\textrm{Zrotation} \newline
$
\end{center}
\end{linenomath}


\section{Unit Quaternion}
\begin{linenomath}
\begin{center}
$
Q_\textrm{Wunit} =  \frac{Q_\textrm{Winput}}{Q_\textrm{normal}}\newline
Q_\textrm{Xunit} =  \frac{Q_\textrm{Xinput}}{Q_\textrm{normal}}\newline
Q_\textrm{Yunit} = \frac{Q_\textrm{Yinput}}{Q_\textrm{normal}}\newline
Q_\textrm{Zunit} =  \frac{Q_\textrm{Zinput}}{Q_\textrm{normal}}\newline
$
\end{center}
\end{linenomath}

\section{Quaternion Dot Product}
\begin{linenomath}
\begin{center}
$
D_\textrm{dot} = Q_\textrm{W1}(Q_\textrm{W2}) + Q_\textrm{X1}(Q_\textrm{X2}) + Q_\textrm{Y1}(Q_\textrm{Y2}) + Q_\textrm{Z1}(Q_\textrm{Z2}) \newline
$
\end{center}
\end{linenomath}

\section{Quaternion Magnitude}
\begin{linenomath}
\begin{center}
$
M_\textrm{magnitude} = \sqrt{Q_\textrm{normal}} \newline
$
\end{center}
\end{linenomath}

\section{Quaternion Additive Inverse}
\begin{linenomath}
\begin{center}
$
Q_\textrm{Wnegative} =  -Q_\textrm{Winput} \newline
Q_\textrm{Xnegative} =  -Q_\textrm{Xinput} \newline
Q_\textrm{Ynegative} =  -Q_\textrm{Yinput} \newline
Q_\textrm{Znegative} =  -Q_\textrm{Zinput} \newline
$
\end{center}
\end{linenomath}

\section{Quaternion Smooth Interpolation Between Quaternions}
\begin{linenomath}
$
Q_\textrm{initial} = Q_\textrm{Unit initial} \newline
Q_\textrm{final} = Q_\textrm{Unit final} \newline
\newline
D_\textrm{dot} = Q_\textrm{initial} \cdot Q_\textrm{final} \newline
\newline
\newline
Q_\textrm{initial} = \begin{cases}
    Q_\textrm{initial} = Q_\textrm{initial(additive inverse)}, & \text{if $D_\textrm{dot}<0$}.\\
     \hspace{1ex}Q_\textrm{initial}, & \text{otherwise}.\\
\end{cases}
\newline
\newline
\newline
D_\textrm{dot}=|D_\textrm{dot}|\newline
\newline
D_\textrm{dot}=\begin{cases}
    \hspace{1ex}1, & \text{if $D_\textrm{dot}>1$}.\\
     \hspace{1ex}D_\textrm{dot}, & \text{otherwise}.\\
\end{cases}
\newline
\newline
\newline
\theta = arccos(D_\textrm{dot}) \times ratio\\
\newline
Q_\textrm{orthonomal} = Q_\textrm{final} - Q_\textrm{initial} \times D_\textrm{dot}\\
Q_\textrm{output} = Q_{initial} \times cos(\theta) + Q_\textrm{orthonomal} \times sin(\theta)\newline
\newline
\newline
\newline
$
\end{linenomath}


\section{Quadcopter Combined Thrust Vector}
$
Q_\textrm{change} =  ( \frac{2  \times (Q_\textrm{target} - Q_\textrm{current}) \times Q_\textrm{current conjugate}}{dT} ) \\
\\
V_\textrm{Xchange} = Q_\textrm{Xchange}\\
V_\textrm{Ychange} = Q_\textrm{Ychange}\\
V_\textrm{Zchange} = Q_\textrm{Zchange}\\
\\
V_\textrm{RotationOutput} = FeedbackController_\textrm{rotation}.Calculate(0, V_\textrm{change})\\
V_\textrm{PositionOutput} = FeedbackController_\textrm{position}.Calculate(0, V_\textrm{CurrentPosition} - V_\textrm{TargetPosition})\\
\\
V_\textrm{YThrusterBOutput} = -V_\textrm{XRotationOutput} + V_\textrm{ZRotationOutput} - V_\textrm{YRotationOutput} \\
V_\textrm{YThrusterCOutput} = -V_\textrm{XRotationOutput} - V_\textrm{ZRotationOutput} + V_\textrm{YRotationOutput} \\
V_\textrm{YThrusterDOutput} = \hspace{2ex}V_\textrm{XRotationOutput} - V_\textrm{ZRotationOutput} - V_\textrm{YRotationOutput} \\
V_\textrm{YThrusterEOutput} = \hspace{2ex}V_\textrm{XRotationOutput} + V_\textrm{ZRotationOutput} + V_\textrm{YRotationOutput} \\
\\
V_\textrm{HoverAngles} = RotationToHoverAngles(Q_\textrm{CurrentRotation})\\
\\
V_\textrm{PositionOutput} = CalculateRotationOffset(Q_\textrm{CurrentRotation}).RotateVector(V_\textrm{PositionOutput})\\
\\
V_\textrm{XPositionOutput} = V_\textrm{XPositionOutput} + V_\textrm{ZHoverAngles}\\
V_\textrm{ZPositionOutput} = V_\textrm{ZPositionOutput} - V_\textrm{XHoverAngles}\\
\\
V_\textrm{ThrusterBOutput} = V_\textrm{ThrusterBOutput} + V_\textrm{PositionOutput}\\
V_\textrm{ThrusterCOutput} = V_\textrm{ThrusterCOutput} + V_\textrm{PositionOutput}\\
V_\textrm{ThrusterDOutput} = V_\textrm{ThrusterDOutput} + V_\textrm{PositionOutput}\\
V_\textrm{ThrusterEOutput} = V_\textrm{ThrusterEOutput} + V_\textrm{PositionOutput}
$


\section{Quadcopter Thruster Position Calculation}
$
V_\textrm{ThrusterBPosition} = Q_\textrm{CurrentRotation}.RotateVector(V_\textrm{ThrusterBOffset}) + V_\textrm{TargetPosition}\\
V_\textrm{ThrusterCPosition} = Q_\textrm{CurrentRotation}.RotateVector(V_\textrm{ThrusterCOffset}) + V_\textrm{TargetPosition}\\
V_\textrm{ThrusterDPosition} = Q_\textrm{CurrentRotation}.RotateVector(V_\textrm{ThrusterDOffset}) + V_\textrm{TargetPosition}\\
V_\textrm{ThrusterEPosition} = Q_\textrm{CurrentRotation}.RotateVector(V_\textrm{ThrusterEOffset}) + V_\textrm{TargetPosition}
$


\section{Quadcopter Hover Angle Calculation}
$
DA_\textrm{Direction} = RotationMatrix.RotateVector(EA_\textrm{rotate} (0, -90, 0), DA_\textrm{Direction} )\\
\newline
DA_\textrm{Direction} = RotationMatrix.RotateVector(EA_\textrm{rotate} (0, DA_\textrm{Rotation}, 0), DA_\textrm{Direction} )\\
\newline
D_\textrm{InnerJoint} = RadiansToDegrees( arcsin(D_\textrm{DirectionVectorZ}) )\\
D_\textrm{OuterJoint} = RadiansToDegrees( arctan2(D_\textrm{DirectionVectorX}, D_\textrm{DirectionVectorY}) )\\
$


\section{Quadcopter Estimate Position}
$
V_\textrm{TBThrust} = Vector(0, ThrustBOutputY, 0)\\
V_\textrm{TCThrust} = Vector(0, ThrustCOutputY, 0)\\
V_\textrm{TDThrust} = Vector(0, ThrustDOutputY, 0)\\
V_\textrm{TEThrust} = Vector(0, ThrustEOutputY, 0)\\
\newline
Q_\textrm{TBR} = EA(ThrustBOutput.X, 0, -ThrustBOutput.Z)\\
Q_\textrm{TCR} = EA(ThrustCOutput.X, 0, -ThrustCOutput.Z)\\
Q_\textrm{TDR} = EA(ThrustDOutput.X, 0, -ThrustDOutput.Z)\\
Q_\textrm{TER} = EA(ThrustEOutput.X, 0, -ThrustEOutput.Z)\\
\newline
V_\textrm{TBThrust} = Q_\textrm{TBR}.RotateVector( TBThrust )\\
V_\textrm{TCThrust} = Q_\textrm{TCR}.RotateVector( TCThrust )\\
V_\textrm{TDThrust} = Q_\textrm{TDR}.RotateVector( TDThrust )\\
V_\textrm{TEThrust} = Q_\textrm{TER}.RotateVector( TEThrust )\\
\newline
V_\textrm{ThrustSum} = V_\textrm{TBThrust} + V_\textrm{TCThrust} + V_\textrm{TDThrust} + V_\textrm{TEThrust}\\
V_\textrm{ThrustSum} = Q_\textrm{current}.RotateVector( V_\textrm{ThrustSum} )\\
\newline
V_\textrm{XDragForce} = D_\textrm{AirDensity} \times D_\textrm{XCurrentVelocity}^2 \times D_\textrm{DragCoefficient} \times Sign ( XCurrentVelocity ) \\
V_\textrm{YDragForce} = D_\textrm{AirDensity} \times D_\textrm{YCurrentVelocity}^2 \times D_\textrm{DragCoefficient} \times Sign ( YCurrentVelocity ) \\
V_\textrm{ZDragForce} = D_\textrm{AirDensity} \times D_\textrm{ZCurrentVelocity}^2 \times D_\textrm{DragCoefficient} \times Sign ( ZCurrentVelocity ) \\
\newline
V_\textrm{CurrentAcceleration} = V_\textrm{ThrustSum} + V_\textrm{WorldAcceleration}\\
V_\textrm{CurrentVelocity} = V_\textrm{CurrentVelocity} + V_\textrm{CurrentAcceleration} \times D_\textrm{TimeDerivative} \\
V_\textrm{CurrentPosition} = V_\textrm{CurrentPosition} + V_\textrm{CurrentVelocity} \times D_\textrm{TimeDerivative} \\
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
$


\section{Quadcopter Estimate Rotation}
$
V_\textrm{TB} = V_\textrm{TBThrustVector}\\
V_\textrm{TC} = V_\textrm{TCThrustVector}\\
V_\textrm{TD} = V_\textrm{TDThrustVector}\\
V_\textrm{TE} = V_\textrm{TEThrustVector}\\
\newline
V_\textrm{TB} = Q_\textrm{CurrentRotation}.RotateVector( TB )\\
V_\textrm{TC} = Q_\textrm{CurrentRotation}.RotateVector( TC )\\
V_\textrm{TD} = Q_\textrm{CurrentRotation}.RotateVector( TD )\\
V_\textrm{TE} = Q_\textrm{CurrentRotation}.RotateVector( TE )\\
\newline
D_\textrm{Torque} = D_\textrm{ArmLength} \times sin( 180 - D_\textrm{ArmAngle} )\\
\newline
V_\textrm{XAngularAcceleration} \hspace{2ex}= ( \hspace{2ex}V_\textrm{TBY} + V_\textrm{TCY} - V_\textrm{TDY} - V_\textrm{TEY} ) \times D_\textrm{Torque}\\
V_\textrm{YAngularAcceleration} \hspace{2ex}= ( \hspace{2ex}V_\textrm{TBX} + V_\textrm{TCX} - V_\textrm{TDX} - V_\textrm{TEY} ) \times D_\textrm{Torque}\\
V_\textrm{YAngularAcceleration}                     += ( \hspace{2ex}V_\textrm{TBZ} - V_\textrm{TCZ} - V_\textrm{TDZ} + V_\textrm{TEZ} ) \times D_\textrm{Torque}\\
V_\textrm{ZAngularAcceleration} \hspace{2ex}= ( -V_\textrm{TBY} + V_\textrm{TCY} + V_\textrm{TDY} - V_\textrm{TEY} ) \times D_\textrm{Torque}\\
\newline
V_\textrm{XDragForce} = D_\textrm{AirDensity} \times D_\textrm{XAngularVelocity}^2 \times D_\textrm{DragCoefficient} \times Sign ( XAngularVelocity ) \\
V_\textrm{YDragForce} = D_\textrm{AirDensity} \times D_\textrm{YAngularVelocity}^2 \times D_\textrm{DragCoefficient} \times Sign ( YAngularVelocity ) \\
V_\textrm{ZDragForce} = D_\textrm{AirDensity} \times D_\textrm{ZAngularVelocity}^2 \times D_\textrm{DragCoefficient} \times Sign ( ZAngularVelocity ) \\
\newline
V_\textrm{DifferentialThrust} = V_\textrm{TB} + V_\textrm{TC} - V_\textrm{TD} - V_\textrm{TE}\\
V_\textrm{AngularAcceleration} = V_\textrm{AngularAcceleration} + V_\textrm{DifferentialThrust}\\
V_\textrm{AngularVelocity} = V_\textrm{AngularVelocity} + ( V_\textrm{AngularAcceleration} - V_\textrm{DragForce} ) \times D_\textrm{TimeDerivative}\\
Q_\textrm{AngularRotation} = \frac {V_\textrm{AngularVelocity} \times D_\textrm{TimeDerivative}} {2}\\
Q_\textrm{AngularPosition} = Q_\textrm{AngularPosition} + Q_\textrm{AngularRotation} \times Q_\textrm{AngularPosition}\\
$

\section{Quadcopter Calculate 3D Yaw}
$
V_\textrm{HoverRotation} = HoverAnglesFromQuaternion(Q_\textrm{CurrentRotation})\\
Q_\textrm{Hover} = EA(V_\textrm{HoverRotation})\\
Q_\textrm{Yaw3D} = Q_\textrm{Hover} \times Q_\textrm{CurrentRotation}.MultiplicativeInverse()\\
\newline
\newline
\newline
\newline
\newline
\newline
$

\section{Quadcopter Gimbal Locked Translation}
$
D_\textrm{Fade} = TriangleWaveGenerator(-90 \longrightarrow 90) \Longrightarrow (0 \longrightarrow 1)\\
D_\textrm{InverseFade} = 1 -  D_\textrm{fade}\\
D_\textrm{Rotation} = 45 \times D_\textrm{fade}\\
\newline
V_\textrm{RotatedControl} = Q_{Calculate3DYaw(CurrentRotation)}.RotateVector(V_\textrm{PositionFeedbackControlOutput})\\
\newline
D_\textrm{TBX} = D_\textrm{TBX} \times D_\textrm{InverseFade} + D_\textrm{RotatedControlX} \times D_\textrm{Fade} + D_\textrm{RotatedControlZ} \times D_\textrm{Fade}\\
D_\textrm{TCX} = D_\textrm{TCX} \times D_\textrm{InverseFade} + D_\textrm{RotatedControlX} \times D_\textrm{Fade} + D_\textrm{RotatedControlZ} \times D_\textrm{Fade}\\
D_\textrm{TDX} = D_\textrm{TDX} \times D_\textrm{InverseFade} + D_\textrm{RotatedControlX} \times D_\textrm{Fade} + D_\textrm{RotatedControlZ} \times D_\textrm{Fade}\\
D_\textrm{TEX} = D_\textrm{TEX} \times D_\textrm{InverseFade} + D_\textrm{RotatedControlX} \times D_\textrm{Fade} + D_\textrm{RotatedControlZ} \times D_\textrm{Fade}\\
\newline
D_\textrm{TBZ} = D_\textrm{TBZ} \times D_\textrm{InverseFade} +  D_\textrm{Rotation}\\
D_\textrm{TCZ} = D_\textrm{TCZ} \times D_\textrm{InverseFade} -  D_\textrm{Rotation}\\
D_\textrm{TDZ} = D_\textrm{TDZ} \times D_\textrm{InverseFade} +  D_\textrm{Rotation}\\
D_\textrm{TEZ} = D_\textrm{TEZ} \times D_\textrm{InverseFade} -  D_\textrm{Rotation}\\
\newline
D_\textrm{PostionControlX} = D_\textrm{PostionControlX} \times D_\textrm{InverseFade}\\
D_\textrm{PostionControlZ} = D_\textrm{PostionControlZ} \times D_\textrm{InverseFade}\\
$



\section{ADRC}
$
D_\textrm{Amplificiation}\\
D_\textrm{Damping}\\
D_\textrm{Plant}\\
P_\textrm{PID}\\
D_\textrm{PrecisionModifier}\\
\newline
D_\textrm{Precision} = D_\textrm{TimeDerivative} \times D_\textrm{PrecisionModifier}
\newline
O_\textrm{CurrentOutput} = (P_\textrm{PID}.Calculate(D_\textrm{SetPoint}, D_\textrm{ProcessVariable}, D_\textrm{TimeDerivate}), O_\textrm{PreviousOutput} )\\
\newline
S_\textrm{State} = ESO_\textrm{ExtendedStateObserver}.Observe(D_\textrm{TimeDerivative}, O_\textrm{CurrentOutput}, D_\textrm{Plant}, D_\textrm{ProcessVariable})\\
\newline
D_\textrm{PreviousOutput} = D_\textrm{CurrentOutput}\\
D_\textrm{CurrentOutput} = NLC_\textrm{NonlinearCombiner}.Combine(O_\textrm{CurrentOutput}, D_\textrm{Plant}, S_\textrm{State}, D_\textrm{Precision})\\
\newline
\newline
\newline
\newline
$

\section{Setpoint Jump Prevention}
$
D_\textrm{Amp2Prec} = D_\textrm{Amplification}^2 \times D_\textrm{Precision}\\
D_\textrm{PrecTD} = D_\textrm{Precision} \times D_\textrm{TargetDerivative}\\
D_\textrm{TargetPrecTD} = D_\textrm{Target} + D_\textrm{PrecTD}\\
\newline
D_\textrm{A1} = \sqrt{D_\textrm{Amp2Prec} \times (D_\textrm{Amp2Prec} + (8 \times |D_\textrm{TargetPrecTD}|))}\\
\newline
D_\textrm{A2} =\frac{ D_\textrm{PrecTD} + Sign(D_\textrm{TargetPrecTD}) \times (D_\textrm{A1} - D_\textrm{Amp2Prec})} {2}\\
\newline
D_\textrm{SignTargetPrecTD} = \frac{Sign(D_\textrm{TargetPrecTD} + D_\textrm{Amp2Prec}) - Sign(D_\textrm{TargetPrecTD} - D_\textrm{Amp2Prec})} {2}
\newline
\newline
D_\textrm{A} = (D_\textrm{PrecTD} + D_\textrm{TargetPrecTD} - D_\textrm{A2}) \times D_\textrm{SignTargetPrecTD} + D_\textrm{A2}\\
\newline
D_\textrm{SignA} = \frac{Sign(D_\textrm{A} + D_\textrm{Amp2Prec}) - Sign(D_\textrm{A} - D_\textrm{Amp2Prec})} {2}
\newline
\newline
D_\textrm{SetpointJumpPrevention} = -D_\textrm{Amplification} \times (\frac{D_\textrm{A}}{D_\textrm{Amp2Prec}})- Sign(D_\textrm{A}) \times D_\textrm{SignA} - D_\textrm{Amplification} \times Sign(D_\textrm{A})\\
$

\section{Nonlinear Combiner}
$
D_\textrm{EstimationE1} = O_\textrm{CurrentOutput} - S_\textrm{StateZ1}\\
D_\textrm{EstimationE2} = O_\textrm{PreviousOutput} - S_\textrm{StateZ2}\\
D_\textrm{NominalControlSignal} = SetPointJumpPrevention(D_\textrm{Target}, D_\textrm{TargetDerivate}, D_\textrm{Amplificiation}, D_\textrm{Precision})\\
\newline
D_\textrm{Combine} = \frac{D_\textrm{NominalControlSignal} + S_\textrm{StateZ3}} {D_\textrm{Plant}}\\
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
\newline
$

\section{Extended State Observer}
$
S_\textrm{Gain1} = 1\\
\newline
S_\textrm{Gain2} = \frac{1} {2 \times dT^{0.5}}\\
\newline
S_\textrm{Gain3} = \frac{2} {25 \times dT^{1.2}}\\
\newline
\newline
D_\textrm{E} = D_\textrm{StateZ1} - D_\textrm{ProcessVariable}\\
D_\textrm{FE} = NonlinearFunction(D_\textrm{E}, 0.5, dT)\\
D_\textrm{FE1} = NonlinearFunction(D_\textrm{E}, 0.25, dT)\\
\newline
S_\textrm{StateZ1} = S_\textrm{StateZ1} + (dT \times S_\textrm{StateZ2}) - (S_\textrm{GainZ1} \times D_\textrm{E})\\
S_\textrm{StateZ2} = S_\textrm{StateZ2} + (dT \times (S_\textrm{StateZ3} + (D_\textrm{Plant} \times D_\textrm{Output}))) - (S_\textrm{GainZ2} \times D_\textrm{FE})\\
S_\textrm{StateZ3} = S_\textrm{StateZ3} - S_\textrm{GainZ3} \times D_\textrm{FE1}\\
$

\section{Nonlinear Function}
$
 Output = \begin{cases}
   \frac{ \eta } { \delta^{(1 - \alpha)} }, & \text{if $|\eta| \le \delta$}.\\
   |\eta|^{\alpha} \times Sign(\eta), & \text{otherwise}.\\
\end{cases}
$


\end{document}